options {
STATIC=false;
OPTIMIZE_TOKEN_MANAGER=true;
FORCE_LA_CHECK=true;
}

PARSER_BEGIN(NomParser)
/*
 *   Copyright (C) 2003-2007  University of Manchester
 *
 *   This library is free software; you can redistribute it and/or
 *   modify it under the terms of the GNU Lesser General Public
 *   License as published by the Free Software Foundation; either
 *   version 2.1 of the License, or (at your option) any later version.
 *
 *   This library is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *   Lesser General Public License for more details.
 *
 *   You should have received a copy of the GNU Lesser General Public
 *   License along with this library; if not, write to the Free Software
 *   Foundation, 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA. 
 *   (or see http://www.gnu.org/copyleft/lesser.html)
 */
package org.openscience.cdk.iupac.parser;

import java.io.StringReader;
import org.openscience.cdk.Molecule;
import org.openscience.cdk.exception.*;
import java.util.*;

/**
 * A class partly generated by <a href="http://javacc.dev.java.net" target="_top">JavaCC</a> which breaks down the chemical name
 * into computable subparts and passes these parts to the MoleculeBuilder.
 *
 * @author David Robinson (University of Manchester)
 * @author Bhupinder Sandhu
 * @author Stephen Tomkinson
 *
 * @cdk.keyword IUPAC name
 */
public class NomParser {
    //private variables needed throughout the program
    private static int mainChainPrefix;
    private static boolean isMainCyclic;

    /** The tempory vector of locations the current group/substiuant is attached to */
    private static Vector tempLocation;

    /** The vector of attached functional groups, with an instance of AttachedGroup for each
     * functional group.
     */
    private static Vector attachedGroups;

    /** The vector of attached substituent, with an instance of AttachedGroup for each
     * substituent.
     */
    private static Vector attachedSubstituents;

    /**
     * Used in the build up of ancient greek style prfixes
     */
    private static int currentNumber;

    /**
     * Parses the chemical name and returns the built molecule.
     *
     * @param stringToParse A case-insensitive name of the chemical to build.
     * @return A molecule which represents the interpretatation of the name.
     * @throws ParseException Any error which occur in the parsing get wrapped
     * up in a ParseException and thrown.
     */
    public static Molecule generate (String stringToParse) throws ParseException, CDKException
    {
        isMainCyclic = false;
        tempLocation = new Vector();
        attachedSubstituents = new Vector();
        attachedGroups = new Vector();
        currentNumber = 0;

        StringReader stringReader = new StringReader (stringToParse.toLowerCase() + "\n");
        NomParser parser = new NomParser (stringReader);               
        parser.completeChemicalName();
        
        //Scan substituents for a too high connection point
        checkConnections (attachedSubstituents.iterator());
        
        //Scan functional groups for a too high connection point
        checkConnections (attachedGroups.iterator());

        MoleculeBuilder moleculeBuilder = new MoleculeBuilder();
        Molecule returnedMolecule = moleculeBuilder.buildMolecule(mainChainPrefix, attachedSubstituents, attachedGroups, isMainCyclic, stringToParse);
        
        return returnedMolecule;
    }

    /**
     * Checks to ensure that all groups/substituents attached to the main chain
     * are connected to a valid atom which occurs on the main chain.
     *
     * @param vectorIterator An iterator which provides instances of AttachedGroup to check
     * @throws ParseException A taylored instance of ParseException so nomen can display
     * the error to the user.
     */
    private static void checkConnections (Iterator vectorIterator) throws ParseException
    {
        while (vectorIterator.hasNext())
        {
            AttachedGroup ag = (AttachedGroup) vectorIterator.next();
            Vector locations = ag.getLocations();

            Iterator locationsIterator = locations.iterator();
            while (locationsIterator.hasNext())
            {
                Token tok = (Token) locationsIterator.next();

                try
                {
                    if (Integer.parseInt(tok.image) > mainChainPrefix)
                    {
                        String mesg = "invalid attachment point " + Integer.parseInt(tok.image) + " must be below " + (mainChainPrefix + 1);
                        throw new ParseException(mesg);
                    }
                }
                catch (NumberFormatException nfe)
                {
                    //Do nothing, as this should never happen
                }
            }
        }
    }
}

PARSER_END(NomParser)

JAVACODE
/**
 * Stores "head tokens", the substituent prefix, in a vector of AttachedGroup objects.
 */
void AddHeadToken() {
    attachedSubstituents.add (new AttachedGroup (tempLocation, currentNumber) );
    tempLocation = new Vector();
}

JAVACODE
void MakeMainChainIntoSubstituent() {
    attachedSubstituents.add (new AttachedGroup (tempLocation, mainChainPrefix) );
    currentNumber = 0;
    mainChainPrefix = 0;
    tempLocation = new Vector();
}

JAVACODE
/**
 * Stores the functional groups in a vector of AttachedGroup objects.
 */
void AddFunGroup() {
    Token tok;
    tok = getToken(-1);
    attachedGroups.add (new AttachedGroup (tempLocation, tok.image) );
    tempLocation = new Vector();
}

JAVACODE
/**
* Stores the functional group positions, the number of the atom they 
* connect to, in an array.
*/
void AddFunGroupPos() {
    Token tok;
    tok = getToken(-1);
    tempLocation.add(tok);
}

JAVACODE
/**
* Adds to the position array a location of -1 to indicate no location was
* specified.
*/
void AddUnknownFunGroupPos() {
    Token tok = new Token();
    tok.image = "-1";
    tempLocation.add(tok);
}

JAVACODE
/**
 * Store the mainChainPrefix token, the chain prefix of the longest carbon chain
 */
void AddMainChain() {
    mainChainPrefix = currentNumber;
    currentNumber = 0;
}

JAVACODE
/**
 * Sets the main chain to be cyclic.
 */
void SetMainCyclic() {
    isMainCyclic = true;
}

TOKEN :
{
	< EOL: "\n" | "\r" >
}

TOKEN : /*NUMBERS*/
{
    < CONSTANT: ( <DIGIT> )+ >
|   < #DIGIT: ["0" - "9"] >
}

TOKEN : /*NUMBER CONNECTORS*/
{
	< DASH: "-" >
|	< COMMA: "," >
}

/**
 * Initial small numbers.
 */
TOKEN :
{
    < METH: "meth" >
|   < ETH: "eth" >
|   < PROP: "prop" >
|   < BUT: "but" >
}

/**
 * Other special cases.
 */
TOKEN :
{
    < UNDEC: "undec" >
|   < EICOS: "eicos" | "icos" >
|   < HENICOS: "henicos" >
}

/**
 * Usual numbers for base 10 numbering.
 */
TOKEN :
{
    < HEN: "hen" >
|   < DO: "do" >
|   < TRI: "tri" >
|   < TETR: "tetra" >
|   < PENT: "pent" >
|   < HEX: "hex" >
|   < HEPT: "hept" >
|   < OCT: "oct" >
|   < NON: "non" >
}

/**
 * Positional aides which give the magnitude of the the base numbers.
 * Equivalent to "...ty" and "...hundred" in English
 */
TOKEN :
{
    < DEC: "dec" >
|   < COS: "cos" >
|   < CONT: "cont" >
}

/* Skip the "a" letter for greek numbers */
SKIP :
{
    < A : "a" > | < SPACE : " " >
}

TOKEN : /*BOND MODIFIERS*/
{
        < AN: "an" >
    |   < EN: "en" >
    |	< YN: "yn" >
}


TOKEN : /*CONNECTOR*/
{
    	< YL: "yl" >
|	< DI: "di" >
|       < CYCLO: "cyclo" >
}

TOKEN :  /*PREFIXES*/
{
            < CHLORO: "chloro" >
	|	< FLUORO: "fluoro" >
	|	< BROMO: "bromo" >
	|	< IODO: "iodo" >
        |       < NITRO: "nitro" >
        |       < OXO: "oxo" >
        |       < PHENYL: "phenyl" >
        |       < AMINO: "amino" >
        |       < ALUMINO: "alumino" >
        |	< LITHO: "litho" >
        |	< HYDROXY: "hydroxy" >
}		
		
TOKEN :  /*FUNCTIONAL GROUP SUFFIXES*/
{
        	< E: "e">
      |     < OL: "ol" >
	|	< OICACID: "oic acid" >
      |     < OYLCHLORIDE: "oyl chloride" >
      |     < NITRILE: "nitrile" >
	|	< AL: "al" >
	|	< AMIDE: "amide" >
	|	< AMINE: "amine" >
	|	< ONE: "one" >
	|	< OATE: "oate" >
}

TOKEN : /* METALS */
{
	< LITHIUM: "lithium" >
|	< SODIUM: "sodium" >
|	< POTASSIUM: "potassium" >
|	< RUBIDIUM: "rubidium" >
|	< CESIUM: "cesium" >
|	< FRANCIUM: "francium" >
|	< BERYLLIUM: "beryllium" >
|	< MAGNESIUM: "magnesium" >
|	< CALCIUM: "calcium" >
|	< STRONTIUM: "strontium" >
|	< BARIUM: "barium" >
|	< RADIUM: "radium">
|	< SCANDIUM: "scandium" >
|	< YTTRIUM: "yttrium" >
|	< LANTHANUM: "lanthanum" >
| 	< ACTINIUM: "actinium" >
|	< TITANIUM: "titanium" >
|	< ZIRCONIUM: "zirconium" >
|	< HAFNIUM: "hafnium" >
|	< RUTHERFORDIUM: "rutherfordium" >
|	< VANADIUM: "vanadium" >
|	< NIOBIUM: "niobium" >
|	< TANTALUM: "tantalum" >
| 	< DUBNIUM: "dubnium" >
|	< CHROMIUM: "chromium" >
|	< MOLYBDENUM: "molybdenum" >
|	< TUNGSTEN: "tungsten" >
|	< SEABORGIUM: "seaborgium" >
|	< MANGANESE: "manganese" >
|	< TECHNETIUM: "technetium" >
|	< RHENIUM: "rhenium" >
|	< BOHRIUM: "bohrium" >
|	< IRON: "iron" >
|	< RUTHENIUM: "ruthenium" >
|	< OSMIUM: "osmium" >
|	< HASSIUM: "hassium" >
|	< COBALT: "cobalt">
|	< RHODIUM: "rhodium">
|	< IRIDIUM: "iridium" >
|	< MEITMERIUM: "meitmerium" >
|	< NICKEL: "nickel" >
|	< PALLADIUM: "palladium" >
|	< PLATINUM: "platinum" >
|	< COPPER: "copper" >
|	< SILVER: "silver" >
|	< GOLD: "gold" >
|	< ZINC: "zinc" >
|	< CADMIUM: "cadmium" >
|	< MECURY: "mercury" >
|	< ALUMINIUM: "aluminium" >
|	< GALLIUM: "gallium" >
|	< INDIUM: "indium" >
|	< THALLIUM: "thallium" >
|	< GERMAINIUM: "germainium" >
|	< TIN: "tin" >
|	< LEAD: "lead" >
|	< ARSENIC: "arsenic" >
|	< ANTIMONY: "antimony" >
|	< BISMUTH: "bismuth" >
|	< SELENIUM: "selenium" >
|	< TELLURIUM: "tellurium" >
|	< POLONIUM: "polonium" >
|	< CERIUM: "cerium" >
|	< PRASEODYMIUM: "praseodymium" >
|	< NEODYMIUM: "neodymium" >
|	< PROMETHIUM: "promethium" >
|	< SANARIUM: "sanarium" >
|	< EUROPIUM: "europium" >
|	< GADOLINIUM: "gadolinium" >
|	< TERBIUM: "terbium" >
|	< DYSPROSIUM: "dysprosium" >
|	< HOLMIUM: "holmium" >
|	< ERBIUM: "erbium" >
|	< THULIUM: "thulium" >
|	< YTTERBIUM: "ytterbium" >
|	< LUTETIUM: "lutetium" >
|	< THORIUM: "thorium" >
|	< PROTACTINIUM: "protactinium" >
|	< URANIUM: "uranium" >
|	< NEPTUNIUM: "neptunium" >
|	< PLUTONIUM: "plutonium" >
|	< AMERCIUM: "amercium" >
|	< CURIUM: "curium" >
|	< BERKELIUM: "berkelium" >
|	< CALIFORNIUM: "californium" >
|	< EINSTEINIUM: "einsteinium" >
|	< FERMIUM: "fermium" >
|	< MENDELEVIUM: "mendelevium" >
|	< NOBELIUM: "nobelium" >
|	< LAWRENCIUM: "lawrencium" >
}

/**
 * The general form all chemical names must follow.
 */
void completeChemicalName() :
{}
{
    LOOKAHEAD (2) ( mainChainConstruct() ) | ( prefixConstruct() mainChainConstruct() ) <EOL>
    
}

/**
 * Allows 1 or more prefixes
 */
void prefixConstruct() :
{}
{
    //Dash not needed in the first case
    prefixType() (<DASH> prefixType())*
}

void prefixType() :
{}
{
    ( attachLocationSpecified()
    | AddUnknownFunGroupPos() ) 

    ( subChain() 
    | functionalGroupPrefix() )
}

/** The substituent part of the prefix */
void subChain() :
{}
{
    //Only allow *specified location* substituents delt with in prefixType()
    chainPrefix() AddHeadToken() <YL>
}

/** 
 * An attach position has been specified using a 
 * comma seperated list followed by a dash
 */
void attachLocationSpecified() :
{}
{
    //Must be at least one constant, so add that to begin with.

    <CONSTANT> AddFunGroupPos()

    (   oneAttachLocation()
    |   twoOrThreeAttachLocations() )
}

/**
 * Only one attach location specified, should be followed by a dash.
 */
void oneAttachLocation() :
{}
{
	 <DASH>
}

/**
 * Two or three attach locations specidied, handle the second and if needed, the third one here.
 */
void twoOrThreeAttachLocations() :
{}
{
	<COMMA> <CONSTANT> AddFunGroupPos() 
        ( (<DASH> <DI>) | (<COMMA> <CONSTANT> AddFunGroupPos() <DASH> <TRI>) )
}

/**
 * A list of known tokens denoting a chain's length.
 */
void chainPrefix() :
{}
{
    specialCase() | allBaseNumbers() [tensWithUnits() | tensNoUnits()]
}

/** Deal with special cases where the rules don't apply. */
void specialCase() :
{}
{
    < METH > {currentNumber = 1;}
|   < ETH > {currentNumber = 2;}
|   < PROP > {currentNumber = 3;}
|   < BUT > {currentNumber = 4;}
|   < DEC > {currentNumber = 10;}
|   < UNDEC > {currentNumber = 11;}
|   < EICOS > {currentNumber = 20;}
|   < HENICOS > {currentNumber = 21;}
}

/** The usual numbers .*/
void allBaseNumbers() :
{}
{
    < HEN > {currentNumber = 1;}
|   < DO > {currentNumber = 2;}
|   < TRI > {currentNumber = 3;}
|   < TETR > {currentNumber = 4;}
|   < PENT > {currentNumber = 5;}
|   < HEX > {currentNumber = 6;}
|   < HEPT > {currentNumber = 7;}
|   < OCT > {currentNumber = 8;}
|   < NON > {currentNumber = 9;}
}

/** Deal with fragments refering to the positioning of the base numbers (denoting their magnitude) */
void tensNoUnits() :
{}
{
    <DEC> { currentNumber += 10; }
|   <COS> { currentNumber += 20; }
|   <CONT> { currentNumber *= 10; }
}

/** 
 * Deals with numbers above 30 where the base numbers set appear twice.
 * For example, in the tens and the units. */
void tensWithUnits() :
{
    int tempBackup;
}
{
    { tempBackup = currentNumber; }
    allBaseNumbers() <CONT>
    { currentNumber *= 10; currentNumber += tempBackup; }
}

/** The functional group part of the prefix */
void functionalGroupPrefix() :
{}
{
    prefixFunctionalGroups()
    AddFunGroup()
}

/**
 * Main chains are compulsary and consist of an optional "cyclo", a length prefix and
 * a posfix denoting functional groups.
 */
void mainChainConstruct() :
{}
{
    [cycle()] mainChainPrefix()( 
    
    <YL>  AddUnknownFunGroupPos() MakeMainChainIntoSubstituent() ( prioritySubstituents()
        | mainChainPrefix() <AN> prioritySubstituentsFunGroups() ) AddUnknownFunGroupPos() AddFunGroup()
    | bondType() mainChainSuffix() )

}

/**
 * Deals with cyclic main chains.
 */
void cycle() :
{}
{
    <CYCLO> SetMainCyclic()
}

/**
 * Deal with the main chain's length.
 */
void mainChainPrefix() :
{}
{
    chainPrefix() AddMainChain()
}


/**
 * Tokens which affect the bond order of the first bond. 
 */
void bondType() :
{}
{
    ( <AN> AddUnknownFunGroupPos()
      | ( <DASH> attachLocationSpecified() | AddUnknownFunGroupPos() ) 
        ( <EN> | <YN> ) )
    AddFunGroup()
}

/**
 * Figure out the functional group by the main chain's suffix.
 */
void mainChainSuffix() :
{}
{
      endFunctionalGroups() | connectingFunctionalGroupsConstruct()
}

/**
 * Functional groups which occur at the end of the main chain and need 
 * a connecting "an". 
 */
void endFunctionalGroups() :
{}
{
(   <E>[<NITRILE>]
|   <AMIDE>
|   <AMINE>
|   <OATE>
|   <ONE>
|   <OICACID>
|   <OYLCHLORIDE>
|   <AL> ) AddUnknownFunGroupPos() AddFunGroup()
}

/**
 * The layout of a functional group(s) which can connect anywhere.
 * No number specified, or a number list specified.
 */
void connectingFunctionalGroupsConstruct() :
{}
{
    (  connectingFunctionalGroupSuffix() AddUnknownFunGroupPos()
    | <DASH> attachLocationSpecified() connectingFunctionalGroupSuffix() )
 
    AddFunGroup()
}

/**
 * Functional groups suffixs for groups which can be connected anywhere 
 * along the main chain.
 */
void connectingFunctionalGroupSuffix() :
{}
{
    <OL>
}

void prefixFunctionalGroups() :
{}
{
	<CHLORO>
|	<BROMO>
|	<IODO>
|	<FLUORO>
|       <NITRO>
|       <OXO>
|       <PHENYL>
|       <AMINO>
|       <HYDROXY>
}

/**
 * Things which have sub chains branching off them and the molecule does have a main chain.
 */
void prioritySubstituentsFunGroups() :
{}
{
    <AMINE>
|   <AMIDE>
|   <OATE>
|   <ONE>
}

/**
 * Things which have sub chains branching off them but the molecule has no main chain.
 */
void prioritySubstituents () :
{}
{
		 groupOneMetals()
|		 groupTwoMetals()
|		 dBlockMetals()
|		 pBlockMetals()
|		 fBlockMetals()

}

void groupOneMetals() :
{}
{
	
	<LITHIUM>
|	<SODIUM>
|	<POTASSIUM>
|	<RUBIDIUM>
|	<CESIUM>
|	<FRANCIUM>

}

void groupTwoMetals() :
{}
{
	<BERYLLIUM>
|	<MAGNESIUM>
|	<CALCIUM>
|	<STRONTIUM>
|	<BARIUM>
|	<RADIUM>
}

void dBlockMetals() :
{}
{
	<SCANDIUM>
|	<YTTRIUM>
|	<LANTHANUM>
| 	<ACTINIUM>
|	<TITANIUM>
|	<ZIRCONIUM>
|	<HAFNIUM>
|	<RUTHERFORDIUM>
|	<VANADIUM>
|	<NIOBIUM>
|	<TANTALUM>
| 	<DUBNIUM>
|	<CHROMIUM>
|	<MOLYBDENUM>
|	<TUNGSTEN>
|	<SEABORGIUM>
|	<MANGANESE>
|	<TECHNETIUM>
|	<RHENIUM>
|	<BOHRIUM>
|	<IRON>
|	<RUTHENIUM>
|	<OSMIUM>
|	<HASSIUM>
|	<COBALT>
|	<RHODIUM>
|	<IRIDIUM>
|	<MEITMERIUM>
|	<NICKEL>
|	<PALLADIUM>
|	<PLATINUM>
|	<COPPER>
|	<SILVER>
|	<GOLD>
|	<ZINC>
|	<CADMIUM>
|	<MECURY>
}

void pBlockMetals() :
{}
{
	<ALUMINIUM>
|	<GALLIUM>
|	<INDIUM>
|	<THALLIUM>
|	<GERMAINIUM>
|	<TIN>
|	<LEAD>
|	<ARSENIC>
|	<ANTIMONY>
|	<BISMUTH>
|	<SELENIUM>
|	<TELLURIUM>
|	<POLONIUM>

}

void fBlockMetals() :
{}
{
	<CERIUM>
|	<PRASEODYMIUM>
|	<NEODYMIUM>
|	<PROMETHIUM>
|	<SANARIUM>
|	<EUROPIUM>
|	<GADOLINIUM>
|	<TERBIUM>
|	<DYSPROSIUM>
|	<HOLMIUM>
|	<ERBIUM>
|	<THULIUM>
|	<YTTERBIUM>
|	<LUTETIUM>
|	<THORIUM>
|	<PROTACTINIUM>
|	<URANIUM>
|	<NEPTUNIUM>
|	<PLUTONIUM>
|	<AMERCIUM>
|	<CURIUM>
|	<BERKELIUM>
|	<CALIFORNIUM>
|	<EINSTEINIUM>
|	<FERMIUM>
|	<MENDELEVIUM>
|	<NOBELIUM>
|	<LAWRENCIUM>

}

